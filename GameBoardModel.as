package{	import flash.events.EventDispatcher;		/**	 * Model 	 */	public class GameBoardModel extends EventDispatcher	{		import flash.events.Event;		import flash.events.EventDispatcher;				public static const DATA_INIT:String = "data_init";				private var _nRow:int;				// Total rows for the game.		private var _nCol:int;				// Total columns for the game.		private var _nPieces:int;			// Total number of hidden pieces for the game.		private var _nSelectedIndex:int;	// Selected index.		private var _nSelectedRow:int;		// Selected row.		private var _nSelectedCol:int;		// Selected column.		private var _nFoundCnt:int;			// Total number of found items.		private var _arrPieces:Array;		// Collection of hidden pieces/items.				/**		 * Constructor for model inits the storage area.		 */		public function GameBoardModel()		{			_arrPieces = [];			super();		}				/**		 * Initializes the data/model		 * 		 * @param	nRow	The number of rows for the game.		 * @param	nCol	The number of columns for the game.		 * @param	nPieces	The number of hidden pieces for the game.		 */		public function initData(nRow:int, nCol:int, nPieces:int):void		{			_nFoundCnt = 0;			_nRow = nRow;			_nCol = nCol;			_nPieces = nPieces;			for(var i:uint = 0;i<_nPieces;i++)			{				var item:Object = createPiece();				_arrPieces.push(item);			}			dispatchEvent(new Event(DATA_INIT));		}				/**		 * Resets the game to play again; by removing items from the pieces array and calling init.		 */		public function reset():void		{			while(_arrPieces.length)				_arrPieces.pop();			initData(_nRow, _nCol, _nPieces);		}				/**		 * Checks to see if the row|column selected contains a hidden item and sets the flag. Updates the found		 * item count if it is needed.		 *		 * @param	nRow	Row of the space selected.		 * @param	nCol	Column of the space selected.		 */		public function selectSpace(nRow:uint, nCol:int):void		{			_nSelectedRow = nRow;			_nSelectedCol = nCol;			_nSelectedIndex = -1;			for(var i:uint = 0;i<_arrPieces.length;i++)			{				trace(":" + _arrPieces[i].row + ":" + _arrPieces[i].col + ":");				if(_arrPieces[i].row == nRow && _arrPieces[i].col == nCol)				{					_nSelectedIndex = i;					_nFoundCnt++;					break;				}			}			dispatchEvent(new Event(Event.CHANGE));						if(_nFoundCnt == _arrPieces.length)				dispatchEvent(new Event(Event.COMPLETE));		}				/**		 * Creates a hidden item/piece. Makes sure no duplicate items are created.		 */		private function createPiece():Object		{			var item:Object;			var found:Boolean = true;						while(found)			{				item =				{					row: Utils.randomRange(0, _nRow - 1),					col: Utils.randomRange(0, _nCol - 1)				};								for(var i:uint = 0;i<_arrPieces.length;i++)				{					if(_arrPieces[i].row == item.row && _arrPieces[i].col == item.col)						break;				}								if(i >= _arrPieces.length)					found = false;			}			return item;		}				/**		 * Gets the total number of rows for the game.		 *		 * @return int		 */		public function get rows():int		{			return _nRow;		}				/**		 * Gets the total number of columns for the game.		 *		 * @return int		 */		public function get cols():int		{			return _nCol;		}				/**		 * Gets the selected index/position;		 *		 * @return int	Index in the pieces array if item is found else -1 if no item is found.		 */		public function get selectedPos():int		{			return _nSelectedIndex;		}				/**		 * Gets the row selected.		 *		 * @return int		 */		public function get selectedRow():int		{			return _nSelectedRow;		}				/**		 * Gets the column selected.		 *		 * @return int		 */		public function get selectedColumn():int		{			return _nSelectedCol;		}				/**		 * Gets the number of hidden items/pieces for the game.		 *		 * @return int		 */		public function get numberHidden():int		{			return _nPieces;		}	}}